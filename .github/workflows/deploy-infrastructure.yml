name: Deploy Infrastructure

run-name: Deploy Infrastructure | ${{ inputs.action }} | ${{ inputs.environment }} | ${{ inputs.profile || 'default' }}

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'apply'
        type: choice
        options:
          - apply
          - destroy
          - force-unlock
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - demo
          - staging
          - production
      profile:
        description: 'Infrastructure profile to use'
        required: false
        default: 'default'
        type: choice
        options:
          - default
          - m3demo1
          - m3demo2

env:
  TERRAFORM_VERSION: '1.5.7'
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  terraform:
    name: 'Terraform ${{ inputs.action }} - ${{ inputs.environment }}'
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    
    defaults:
      run:
        working-directory: ./terraform

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}

    - name: Azure Login
      uses: azure/login@v1
      with:
        creds: |
          {
            "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
            "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
            "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
            "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
          }

    - name: Execute Terraform Action
      shell: pwsh
      run: |
        # Determine profile parameter
        $profileParam = if ("${{ inputs.profile }}" -ne "default" -and "${{ inputs.profile }}" -ne "") { 
          "-Profile ${{ inputs.profile }}" 
        } else { 
          "" 
        }
        
        # For apply, run plan first then apply
        if ("${{ inputs.action }}" -eq "apply") {
          Write-Host "Running plan first..."
          $planCmd = "./deploy.ps1 -Action plan -Environment ${{ inputs.environment }} -Location `"${{ vars.AZURE_LOCATION || 'westeurope' }}`" -TerraformStateRG `"${{ secrets.TERRAFORM_STATE_RG }}`" -TerraformStateSA `"${{ secrets.TERRAFORM_STATE_SA }}`" -TerraformStateContainer `"${{ secrets.TERRAFORM_STATE_CONTAINER }}`" $profileParam"
          Invoke-Expression $planCmd
          
          if ($LASTEXITCODE -eq 0) {
            Write-Host "Plan successful, proceeding with apply..."
            $applyCmd = "./deploy.ps1 -Action apply -Environment ${{ inputs.environment }} -Location `"${{ vars.AZURE_LOCATION || 'westeurope' }}`" -AutoApprove -TerraformStateRG `"${{ secrets.TERRAFORM_STATE_RG }}`" -TerraformStateSA `"${{ secrets.TERRAFORM_STATE_SA }}`" -TerraformStateContainer `"${{ secrets.TERRAFORM_STATE_CONTAINER }}`" $profileParam"
            Invoke-Expression $applyCmd
          } else {
            Write-Error "Plan failed, aborting apply"
            exit 1
          }
        } else {
          # For destroy, run directly
          $destroyCmd = "./deploy.ps1 -Action ${{ inputs.action }} -Environment ${{ inputs.environment }} -Location `"${{ vars.AZURE_LOCATION || 'westeurope' }}`" -AutoApprove -TerraformStateRG `"${{ secrets.TERRAFORM_STATE_RG }}`" -TerraformStateSA `"${{ secrets.TERRAFORM_STATE_SA }}`" -TerraformStateContainer `"${{ secrets.TERRAFORM_STATE_CONTAINER }}`" $profileParam"
          Invoke-Expression $destroyCmd
        }

    - name: Save Terraform Outputs
      if: inputs.action == 'apply'
      id: outputs
      shell: pwsh
      run: |
        "## Terraform Outputs" | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY
        terraform output -json | jq . | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY
        
        # Save specific outputs for other workflows
        $clusterName = terraform output -raw cluster_name
        $resourceGroupName = terraform output -raw resource_group_name
        "aks_cluster_name=$clusterName" | Add-Content $env:GITHUB_OUTPUT
        "resource_group_name=$resourceGroupName" | Add-Content $env:GITHUB_OUTPUT

    - name: Get AKS Credentials
      if: inputs.action == 'apply'
      shell: pwsh
      run: |
        $resourceGroupName = terraform output -raw resource_group_name
        $clusterName = terraform output -raw cluster_name
        az aks get-credentials --resource-group $resourceGroupName --name $clusterName --overwrite-existing

    - name: Verify ArgoCD Installation
      if: inputs.action == 'apply'
      shell: pwsh
      run: |
        "## ArgoCD Status" | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY
        kubectl get pods -n argocd | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY
        
        "## ArgoCD Applications" | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY
        kubectl get applications -n argocd | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY

    - name: Wait for ArgoCD Applications
      if: inputs.action == 'apply'
      shell: pwsh
      run: |
        "## Waiting for ArgoCD Applications to Sync" | Add-Content $env:GITHUB_STEP_SUMMARY
        "" | Add-Content $env:GITHUB_STEP_SUMMARY
        
        # Wait for ArgoCD applications to be created and synced
        "Waiting for ArgoCD applications to be deployed..." | Add-Content $env:GITHUB_STEP_SUMMARY
        
        for ($i = 1; $i -le 60; $i++) {
          # Check if applications exist
          try {
            $reliabilityAppStatus = kubectl get application reliability-demo -n argocd -o jsonpath='{.status.health.status}' 2>$null
            if (-not $reliabilityAppStatus) { $reliabilityAppStatus = "NotFound" }
          } catch {
            $reliabilityAppStatus = "NotFound"
          }
          
          try {
            $lgtmAppStatus = kubectl get application lgtm-monitoring -n argocd -o jsonpath='{.status.health.status}' 2>$null
            if (-not $lgtmAppStatus) { $lgtmAppStatus = "NotFound" }
          } catch {
            $lgtmAppStatus = "NotFound"
          }
          
          Write-Host "Attempt $i/60: reliability-demo=$reliabilityAppStatus, lgtm-monitoring=$lgtmAppStatus"
          
          if ($reliabilityAppStatus -eq "Healthy" -and $lgtmAppStatus -eq "Healthy") {
            Write-Host "✓ All ArgoCD applications are healthy"
            break
          }
          
          if ($i -eq 60) {
            Write-Host "⚠️ Applications not all healthy after 10 minutes, continuing anyway"
            kubectl get applications -n argocd
          }
          
          Start-Sleep 10
        }

    - name: Get Load Balancer IP Addresses
      if: inputs.action == 'apply'
      shell: pwsh
      run: |
        "## Load Balancer IP Addresses" | Add-Content $env:GITHUB_STEP_SUMMARY
        "" | Add-Content $env:GITHUB_STEP_SUMMARY
        
        # Wait for load balancer IPs to be assigned (up to 10 minutes)
        "Waiting for load balancer IPs to be assigned..." | Add-Content $env:GITHUB_STEP_SUMMARY
        
        # Get ArgoCD Server IP
        $argoCdIp = ""
        for ($i = 1; $i -le 60; $i++) {
          try {
            $argoCdIp = kubectl get svc argocd-server -n argocd -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>$null
          } catch {
            $argoCdIp = ""
          }
          
          if ($argoCdIp -and $argoCdIp -ne "null" -and $argoCdIp -ne "") {
            Write-Host "✓ ArgoCD IP found: $argoCdIp"
            break
          }
          Write-Host "Waiting for ArgoCD load balancer IP... (attempt $i/60)"
          Start-Sleep 10
        }
        
        # Get Reliability Demo Web App IP
        $webAppIp = ""
        for ($i = 1; $i -le 60; $i++) {
          try {
            $webAppIp = kubectl get svc reliability-demo -n reliability-demo -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>$null
          } catch {
            $webAppIp = ""
          }
          
          if ($webAppIp -and $webAppIp -ne "null" -and $webAppIp -ne "") {
            Write-Host "✓ Reliability Demo IP found: $webAppIp"
            break
          }
          Write-Host "Waiting for Web App load balancer IP... (attempt $i/60)"
          # Check if service exists
          try {
            kubectl get svc reliability-demo -n reliability-demo 2>$null
          } catch {
            Write-Host "Service not found yet"
          }
          Start-Sleep 10
        }
        
        # Get Grafana IP
        $grafanaIp = ""
        for ($i = 1; $i -le 60; $i++) {
          try {
            $grafanaIp = kubectl get svc grafana -n monitoring -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>$null
          } catch {
            $grafanaIp = ""
          }
          
          if ($grafanaIp -and $grafanaIp -ne "null" -and $grafanaIp -ne "") {
            Write-Host "✓ Grafana IP found: $grafanaIp"
            break
          }
          Write-Host "Waiting for Grafana load balancer IP... (attempt $i/60)"
          # Check if service exists
          try {
            kubectl get svc grafana -n monitoring 2>$null
          } catch {
            Write-Host "Service not found yet"
          }
          Start-Sleep 10
        }
        
        "### ArgoCD Server" | Add-Content $env:GITHUB_STEP_SUMMARY
        if ($argoCdIp -and $argoCdIp -ne "null") {
          "- **IP Address:** $argoCdIp" | Add-Content $env:GITHUB_STEP_SUMMARY
          "- **URL:** http://$argoCdIp" | Add-Content $env:GITHUB_STEP_SUMMARY
        } else {
          "- **Status:** Load balancer IP not yet assigned" | Add-Content $env:GITHUB_STEP_SUMMARY
          "- **Access:** kubectl port-forward svc/argocd-server -n argocd 8080:80" | Add-Content $env:GITHUB_STEP_SUMMARY
        }
        "" | Add-Content $env:GITHUB_STEP_SUMMARY
        
        "### Reliability Demo Web App" | Add-Content $env:GITHUB_STEP_SUMMARY
        if ($webAppIp -and $webAppIp -ne "null") {
          "- **IP Address:** $webAppIp" | Add-Content $env:GITHUB_STEP_SUMMARY
          "- **URL:** http://$webAppIp" | Add-Content $env:GITHUB_STEP_SUMMARY
        } else {
          "- **Status:** Load balancer IP not yet assigned" | Add-Content $env:GITHUB_STEP_SUMMARY
          "- **Access:** kubectl port-forward svc/reliability-demo -n reliability-demo 8080:80" | Add-Content $env:GITHUB_STEP_SUMMARY
        }
        "" | Add-Content $env:GITHUB_STEP_SUMMARY
        
        "### Grafana Dashboard" | Add-Content $env:GITHUB_STEP_SUMMARY
        if ($grafanaIp -and $grafanaIp -ne "null") {
          "- **IP Address:** $grafanaIp" | Add-Content $env:GITHUB_STEP_SUMMARY
          "- **URL:** http://$grafanaIp" | Add-Content $env:GITHUB_STEP_SUMMARY
        } else {
          "- **Status:** Load balancer IP not yet assigned" | Add-Content $env:GITHUB_STEP_SUMMARY
          "- **Access:** kubectl port-forward svc/grafana -n monitoring 3000:3000" | Add-Content $env:GITHUB_STEP_SUMMARY
        }
        "" | Add-Content $env:GITHUB_STEP_SUMMARY

    - name: Get ArgoCD Access Info
      if: inputs.action == 'apply'
      shell: pwsh
      run: |
        "## ArgoCD Access Information" | Add-Content $env:GITHUB_STEP_SUMMARY
        "" | Add-Content $env:GITHUB_STEP_SUMMARY
        
        # Get ArgoCD password
        $argoCdPasswordB64 = kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}"
        $argoCdPassword = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($argoCdPasswordB64))
        "### Admin Credentials" | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY
        "Username: admin" | Add-Content $env:GITHUB_STEP_SUMMARY
        "Password: $argoCdPassword" | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY

    - name: Get Grafana Access Info
      if: inputs.action == 'apply'
      shell: pwsh
      run: |
        "## Grafana Access Information" | Add-Content $env:GITHUB_STEP_SUMMARY
        "" | Add-Content $env:GITHUB_STEP_SUMMARY
        
        # Get Grafana password
        $grafanaPasswordB64 = kubectl -n monitoring get secret grafana -o jsonpath="{.data.admin-password}"
        $grafanaPassword = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($grafanaPasswordB64))
        "### Admin Credentials" | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY
        "Username: admin" | Add-Content $env:GITHUB_STEP_SUMMARY
        "Password: $grafanaPassword" | Add-Content $env:GITHUB_STEP_SUMMARY
        '```' | Add-Content $env:GITHUB_STEP_SUMMARY